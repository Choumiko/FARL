require('util')
local find_key = require 'lib_control'.find_key
local rotate_bounding_box = require 'lib_control'.rotate_bounding_box

--Mostly taken from https://github.com/dewiniaid/RailTools
local rcd = defines.rail_connection_direction
local rd = defines.rail_direction

local librail = {
    signal_data = {},
    connected_rail_permutations = {},
    cr_straight_first = {},
    all_connected_rail_permutations = {},
    rcd_straight_first = {
        rcd.straight,
        rcd.left,
        rcd.right
    }
}
-- Generate permutations of connected rail arguments.
for _, rail_direction in pairs(rd) do
    librail.connected_rail_permutations[rail_direction] = {}
    librail.cr_straight_first[rail_direction] = {}
    for _, rail_connection_direction in pairs(rcd) do
        local t = {rail_direction=rail_direction, rail_connection_direction=rail_connection_direction}
        table.insert(librail.connected_rail_permutations[rail_direction], t)
        table.insert(librail.all_connected_rail_permutations, t)
    end
    for _, rail_connection_direction in pairs(librail.rcd_straight_first) do
        local t = {rail_direction=rail_direction, rail_connection_direction=rail_connection_direction}
        table.insert(librail.cr_straight_first[rail_direction], t)
    end
end

function librail.create_lookup()
    local dir = defines.direction
    -- We supply offsets for north and northeast facings only.  All others are generated by calculating rotations, using
    -- this table.
    local _rotations = {
        {dir.north, dir.east},
        {dir.northeast, dir.southeast},
        {dir.east, dir.south},
        {dir.southeast, dir.southwest},
        {dir.south, dir.west},
        {dir.southwest, dir.northwest},
    }

    local function each_rotation()
        local i = 0
        return function()
            i = i + 1
            if _rotations[i] then return unpack(_rotations[i]) end
            return nil
        end
    end


    -- Performs a 90 degree rotation of src
    local function rotate_cw(src)
        local t = table.deepcopy(src)
        t.x, t.y = -t.y, t.x
        if t.d then
            t.d = (t.d + 2) % 8
        end
        return t
    end

    local t
    --Arbitrary number, must be greater than the number of manually-assigned chiralities.
    local number_of_chiralities = 100
    for entity_type, entity_data in pairs(librail.rail_data) do
        log(entity_type)
        -- Add rotations for directions other than north and northeast.
        -- This could be simplified, but this reads better.  And it's not a performance critical segment of code.
        for source, dest in each_rotation() do
            log("from " .. find_key(dir, source) .. " to " .. find_key(dir, dest))
            t = {
                length = entity_data[source].length,
                signals = {},
                travel_to_rd = {},
                rd_to_travel = {},
                clear_area = table.deepcopy(entity_data[source].clear_area)
            }

            for d, signals in pairs(entity_data[source].signals) do
                t.signals[d] = {}
                for i = 1, #signals do
                    t.signals[d][i] = rotate_cw(signals[i])
                    t.signals[d][i].stops = signals[i].stops
                    t.signals[d][i].starts = signals[i].starts
                end
            end
            entity_data[dest] = t

            local t_rd = entity_data[source].travel_to_rd
            local calc_td--, set_rd
            for td, _rd in pairs(t_rd) do
                calc_td = (td + 2) % 8
                entity_data[dest].travel_to_rd[calc_td] = _rd
                entity_data[dest].rd_to_travel[_rd] = calc_td
            end
            local _t = {}
            for d, connected_rails in pairs(entity_data[source].next_rails) do
                _t[d] = {}
                for conn_dir, rail in pairs(connected_rails) do
                    _t[d][conn_dir] = {}
                    if not rail then
                        _t[d][conn_dir] = false
                    else
                        _t[d][conn_dir] = librail.rotate_next_rails(connected_rails[conn_dir])
                    end
                end
            end
            entity_data[dest].next_rails = _t

            if entity_data[source].clear_area then
                rotate_bounding_box(entity_data[dest].clear_area, dest - source)
            end
        end

        -- Second pass: Create the signal map and determine signal search areas.
        for entity_direction, direction_data in pairs(entity_data) do
            direction_data.chirality = number_of_chiralities
            number_of_chiralities = number_of_chiralities + 1
            direction_data.signal_map = {}
            for rail_direction, signals in pairs(direction_data.signals) do
                for i=1, #signals do
                    local offset = signals[i]
                    offset.index = i

                    -- Generate a map of where our signals are
                    direction_data.signal_map[librail.offset_to_key(offset)] = {
                        rail_direction = rail_direction, x = offset.x, y = offset.y, index = i, d = offset.d,
                        stops=offset.stops, starts=offset.starts
                    }
                    -- Do the same thing in reverse for signals.
                    local signal = librail.signal_data[offset.d]
                    if not signal then
                        signal = { rail_map = {} }
                        librail.signal_data[offset.d] = signal
                    end
                    if not signal.rail_map[entity_type] then
                        signal.rail_map[entity_type] = {}
                    end

                    local k = librail.args_to_key(-offset.x, -offset.y, entity_direction)
                    signal.rail_map[entity_type][k] = {
                        direction = entity_direction,
                        rail_direction = rail_direction, signal_index = i, signal = offset, rail_data = direction_data,
                        x = -offset.x, y = -offset.y, d = entity_direction,
                    }
                end
            end
        end
    end
    librail.rail_data['straight-rail'][dir.north].chirality = 0
    librail.rail_data['curved-rail'][dir.south].chirality = 0
    librail.rail_data['curved-rail'][dir.southwest].chirality = 0
    librail.rail_data['straight-rail'][dir.southeast].chirality = 0

    librail.rail_data['straight-rail'][dir.east].chirality = 1
    librail.rail_data['curved-rail'][dir.west].chirality = 1
    librail.rail_data['curved-rail'][dir.northwest].chirality = 1
    librail.rail_data['straight-rail'][dir.southwest].chirality = 1

    librail.rail_data['straight-rail'][dir.northeast].chirality = 2
    librail.rail_data['curved-rail'][dir.southeast].chirality = 2

    librail.rail_data['straight-rail'][dir.northwest].chirality = 3
    librail.rail_data['curved-rail'][dir.northeast].chirality = 3
end

function librail.rotate_next_rails(src)
    local t = table.deepcopy(src)
    t.position.x, t.position.y = -t.position.y, t.position.x
    t.direction = ((t.direction or 0) + 2) % 8
    return t
end

--- Generates a unique key for a given offset
-- Currently assumes offsets will never be bigger than +/- 10 or so, which satisfies the needs of our library.
-- @param offset The offset to use.  Must be a table with x, y and d elements.
function librail.offset_to_key(offset)
    -- Offsets are no bigger than 10.  Generate a reasonable key based on them for fast lookups.
    -- They're also always directional...
    return librail.args_to_key(offset.x, offset.y, offset.d)
end

--- Generates a unique key for a given x/y/direction
-- Currently assumes offsets will never be bigger than +/- 10 or so, which satisfies the needs of our library.
-- @param x The x coordinate
-- @param y The y coordinate
-- @param d The direction.
function librail.args_to_key(x, y, d)
    -- log("x=" .. x .. "; y=" .. y .. "; d=" .. d .. "; k=" .. x*1000000 + y*1000 + d)
    return (x+5)*1000000 + (y+5)*1000 + d
end

return librail